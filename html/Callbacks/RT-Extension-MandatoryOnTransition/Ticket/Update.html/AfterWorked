<%args>
$Ticket
</%args>
<%init>
my ($core, $cfs, $roles) = RT::Extension::MandatoryOnTransition->RequiredFields(
    Ticket  => $Ticket,
    To      => $ARGS{'Status'} || $ARGS{'DefaultStatus'},
);
return unless @$cfs or @$roles;

my $comp = '/Elements/EditCustomFields';
my %obj_args = ( Object => $Ticket );

# Handle location in 4.0 and 4.2
if (!$m->comp_exists('/Elements/EditCustomFields')) {
    $comp = '/Ticket/Elements/EditCustomFields';
    %obj_args = ( TicketObj => $Ticket );
}

my @roles;
foreach my $role (@{$roles}) {

    if ( $role =~ s/^CustomRole\.//i ) {
        my $role_object = RT::CustomRole->new($session{CurrentUser});
        my ($ret, $msg) = $role_object->Load($role);
        unless ( $ret ) {
            RT::Logger->error("Unable to load custom role $role: $msg");
            next;
        }

        # Update page already contains single member role groups
        next if $role_object->SingleValue;

        push @roles, $role_object;
    }
}
</%init>
%# 'Named' is handled by this extension in the MassageCustomFields callback
% if ( @$cfs ) {
    <& $comp,
        %ARGS,
        %obj_args,
        InTable     => 1,
        Named       => $cfs,
        &>
% }
% if ( @$roles ) {
%     foreach my $role (@roles) {
        <tr>
            <td class="label">Add <% $role->Name %>:</td>
            <td class="entry">
                <& /Elements/EmailInput,
                    Name               => $role->GroupType,
                    Autocomplete       => 1,
                    AutocompleteNobody => 0,
                    AutocompleteReturn => "Email",
                    Size               => 20,
                    Default            => $ARGS{$role->GroupType},
                &>
            </td>
        </tr>
%     }
% }
